DATA CLEANING -
UPDATED 

import pandas as pd
import numpy as np

# Load the dataset
df = pd.read_excel('drug_demand_forecasting.xlsx', sheet_name='Sheet1')

# Step 1: Handle Missing Values
# Replace '.' with NaN and handle missing values appropriately
df.replace('.', np.nan, inplace=True)

# Convert numeric columns to float where applicable
numeric_columns = ['Demand', 'Weekday', 'Prescription_Volume']
for col in numeric_columns:
    df[col] = pd.to_numeric(df[col], errors='coerce')

# Fill missing numeric values with median
for col in numeric_columns:
    df[col].fillna(df[col].median(), inplace=True)

# Fill missing categorical values with mode
categorical_columns = ['Season', 'Month', 'Drug_Type']
for col in categorical_columns:
    df[col].fillna(df[col].mode()[0], inplace=True)

# Step 2: Clean the 'Age' Column
# Convert age ranges to numeric midpoints
def process_age(value):
    if isinstance(value, str) and '-' in value:  # Handle ranges like '26-35'
        start, end = map(int, value.split('-'))
        return (start + end) / 2
    elif value == '60+':  # Handle '60+'
        return 65  # Assume 65 as a midpoint
    else:
        return value  # Leave numeric values as-is

df['Age'] = df['Age'].apply(process_age)

# Step 3: Encode Categorical Variables
# One-hot encode categorical features
encoded_df = pd.get_dummies(df, columns=['Region', 'Category', 'Drug_Type', 'Season', 'Month', 'age_group'], drop_first=True)

# Step 4: Drop Irrelevant Columns
# Remove columns that won't contribute to numerical modeling
encoded_df.drop(columns=['Date', 'Drug', 'Sides', 'Event', 'Market_News', 'Press_Release'], inplace=True)

# Step 5: Save Cleaned Data
encoded_df.to_csv('cleaned_drug_demand_data.csv', index=False)

print("Data cleaning complete. Cleaned data saved as 'cleaned_drug_demand_data.csv'.")



showing this error - please update

/var/folders/tz/bzpxrq3s5pq07q_tx0q6gnkc0000gn/T/ipykernel_30314/596143333.py:9: FutureWarning: Downcasting behavior in `replace` is deprecated and will be removed in a future version. To retain the old behavior, explicitly call `result.infer_objects(copy=False)`. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  df.replace('.', np.nan, inplace=True)
/var/folders/tz/bzpxrq3s5pq07q_tx0q6gnkc0000gn/T/ipykernel_30314/596143333.py:18: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.
The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.

For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.


  df[col].fillna(df[col].median(), inplace=True)
/var/folders/tz/bzpxrq3s5pq07q_tx0q6gnkc0000gn/T/ipykernel_30314/596143333.py:23: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.
The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.

For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.


  df[col].fillna(df[col].mode()[0], inplace=True)
