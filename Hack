from fastapi import FastAPI, Query
from pydantic import BaseModel
import pandas as pd
import numpy as np
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.ensemble import RandomForestRegressor
import joblib

# Initialize FastAPI app
app = FastAPI()

# Load the dataset
df_cleaned = pd.read_csv('cleaned_drug_demand_data.csv')
df_cleaned['Date'] = pd.date_range(start='2020-01-01', periods=len(df_cleaned), freq='D')
df_cleaned.set_index('Date', inplace=True)

# Prepare data for Random Forest
X = df_cleaned.drop(columns=['Demand'])
y = df_cleaned['Demand']

# Train a Random Forest model
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X, y)

# Save the trained model for future use
joblib.dump(rf_model, 'random_forest_model.pkl')


# Define request models for user input
class ForecastInput(BaseModel):
    p: int = Query(1, description="Order of AR component")
    d: int = Query(1, description="Order of differencing")
    q: int = Query(1, description="Order of MA component")
    P: int = Query(1, description="Seasonal order of AR component")
    D: int = Query(1, description="Seasonal order of differencing")
    Q: int = Query(1, description="Seasonal order of MA component")
    s: int = Query(12, description="Seasonal period")
    steps: int = Query(30, description="Number of steps to forecast")


class PredictionInput(BaseModel):
    features: dict


# API for forecasting and prediction
@app.post("/model/")
def run_model(
    mode: str = Query("forecast", description="'forecast' for time-series or 'predict' for feature-based"),
    forecast_params: ForecastInput = None,
    prediction_params: PredictionInput = None,
):
    """
    Perform demand forecasting or prediction based on the selected mode.
    """
    if mode == "forecast":
        if forecast_params is None:
            return {"error": "Forecasting parameters are required for this mode."}
        
        # Split the dataset into training and test sets
        train_size = int(len(df_cleaned) * 0.8)
        train_data = df_cleaned['Demand'][:train_size]

        # Fit SARIMA model
        model_sarima = SARIMAX(
            train_data,
            order=(forecast_params.p, forecast_params.d, forecast_params.q),
            seasonal_order=(forecast_params.P, forecast_params.D, forecast_params.Q, forecast_params.s),
        )
        model_sarima_fit = model_sarima.fit(disp=False)

        # Forecast
        forecast = model_sarima_fit.forecast(steps=forecast_params.steps)
        forecast_dates = pd.date_range(start=df_cleaned.index[-1], periods=forecast_params.steps + 1, freq='D')[1:]

        # Format the forecast results
        forecast_results = {
            "Forecast": {str(date): round(value, 2) for date, value in zip(forecast_dates, forecast)}
        }
        return forecast_results

    elif mode == "predict":
        if prediction_params is None:
            return {"error": "Prediction parameters are required for this mode."}
        
        # Load the trained Random Forest model
        model_rf = joblib.load('random_forest_model.pkl')

        # Convert features to DataFrame
        input_features = pd.DataFrame([prediction_params.features])

        # Predict demand
        prediction = model_rf.predict(input_features)
        return {"Prediction": round(prediction[0], 2)}

    else:
        return {"error": "Invalid mode. Choose 'forecast' or 'predict'."}


# Root endpoint
@app.get("/")
def root():
    """
    Root endpoint to check API status.
    """
    return {"message": "Demand Forecasting and Prediction API is running. Use /model endpoint to generate results."}
